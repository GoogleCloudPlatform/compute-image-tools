"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _Distro:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DistroEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Distro.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    DISTRO_UNKNOWN: Distro.ValueType = ...  # 0
    WINDOWS: Distro.ValueType = ...  # 1000
    DEBIAN: Distro.ValueType = ...  # 2000
    UBUNTU: Distro.ValueType = ...  # 2001
    KALI: Distro.ValueType = ...  # 2002
    OPENSUSE: Distro.ValueType = ...  # 3000
    SLES: Distro.ValueType = ...  # 3001
    SLES_SAP: Distro.ValueType = ...  # 3002
    FEDORA: Distro.ValueType = ...  # 4000
    RHEL: Distro.ValueType = ...  # 4001
    CENTOS: Distro.ValueType = ...  # 4002
    AMAZON: Distro.ValueType = ...  # 4003
    ORACLE: Distro.ValueType = ...  # 4004
    ROCKY: Distro.ValueType = ...  # 4005
    ARCH: Distro.ValueType = ...  # 5000
    CLEAR: Distro.ValueType = ...  # 6000
class Distro(_Distro, metaclass=_DistroEnumTypeWrapper):
    """Distro denotes a product line of operating systems, using the following
    test:
      If two operating systems at the same version and CPU architecture can be
      imported using the same logic, then they have the same Distro. For example,
      if Ubuntu 20.04 and xubuntu 20.04 are importable using
      the same logic, then they'd both be categorized as Distro.UBUNTU.

    When adding new members, keep in mind:
     - Group distros by family, using buckets of size 1000.
     - The following properties are orthogonal and should not be encoded here:
         - CPU architecture
         - Major or minor versions
         - GCE licensing (such as BYOL)
    """
    pass

DISTRO_UNKNOWN: Distro.ValueType = ...  # 0
WINDOWS: Distro.ValueType = ...  # 1000
DEBIAN: Distro.ValueType = ...  # 2000
UBUNTU: Distro.ValueType = ...  # 2001
KALI: Distro.ValueType = ...  # 2002
OPENSUSE: Distro.ValueType = ...  # 3000
SLES: Distro.ValueType = ...  # 3001
SLES_SAP: Distro.ValueType = ...  # 3002
FEDORA: Distro.ValueType = ...  # 4000
RHEL: Distro.ValueType = ...  # 4001
CENTOS: Distro.ValueType = ...  # 4002
AMAZON: Distro.ValueType = ...  # 4003
ORACLE: Distro.ValueType = ...  # 4004
ROCKY: Distro.ValueType = ...  # 4005
ARCH: Distro.ValueType = ...  # 5000
CLEAR: Distro.ValueType = ...  # 6000
global___Distro = Distro


class _Architecture:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ArchitectureEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Architecture.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    ARCHITECTURE_UNKNOWN: Architecture.ValueType = ...  # 0
    X86: Architecture.ValueType = ...  # 1
    X64: Architecture.ValueType = ...  # 2
class Architecture(_Architecture, metaclass=_ArchitectureEnumTypeWrapper):
    pass

ARCHITECTURE_UNKNOWN: Architecture.ValueType = ...  # 0
X86: Architecture.ValueType = ...  # 1
X64: Architecture.ValueType = ...  # 2
global___Architecture = Architecture


class OsRelease(google.protobuf.message.Message):
    """OsRelease records the name and version of an operating system."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CLI_FORMATTED_FIELD_NUMBER: builtins.int
    DISTRO_FIELD_NUMBER: builtins.int
    MAJOR_VERSION_FIELD_NUMBER: builtins.int
    MINOR_VERSION_FIELD_NUMBER: builtins.int
    ARCHITECTURE_FIELD_NUMBER: builtins.int
    DISTRO_ID_FIELD_NUMBER: builtins.int
    cli_formatted: typing.Text = ...
    """cli_formatted is a concatenation of distro, major_version, and
    minor_version using the format expected by the `--os` flag.
    For examples, see:
     https://cloud.google.com/sdk/gcloud/reference/compute/images/import#--os
    """

    distro: typing.Text = ...
    """distro is the lowercase name of the distribution. Examples:
    [centos, debian, opensuse, rhel, sles, sles-sap, ubuntu, windows]
    """

    major_version: typing.Text = ...
    """major_version of the OS, as represented by the vendor.
    Examples:
      - Windows 2008r2: 2008
      - Ubuntu 18.04:  18
      - OpenSUSE Tumbleweed: tumbleweed
    """

    minor_version: typing.Text = ...
    """minor_version of the OS, as formatted by the vendor.
    Examples:
      - Windows 2008r2: r2
      - Ubuntu 18.04:  04
      - OpenSUSE Tumbleweed: <empty>
    """

    architecture: global___Architecture.ValueType = ...
    distro_id: global___Distro.ValueType = ...
    """Enumerated representation of the distro. Prefer this for
    programmatic usage.
    """

    def __init__(self,
        *,
        cli_formatted : typing.Text = ...,
        distro : typing.Text = ...,
        major_version : typing.Text = ...,
        minor_version : typing.Text = ...,
        architecture : global___Architecture.ValueType = ...,
        distro_id : global___Distro.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["architecture",b"architecture","cli_formatted",b"cli_formatted","distro",b"distro","distro_id",b"distro_id","major_version",b"major_version","minor_version",b"minor_version"]) -> None: ...
global___OsRelease = OsRelease

class InspectionResults(google.protobuf.message.Message):
    """InspectionResults contains metadata determined using automated inspection
    of the guest image.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ErrorWhen:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ErrorWhenEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ErrorWhen.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NO_ERROR: InspectionResults.ErrorWhen.ValueType = ...  # 0
        STARTING_WORKER: InspectionResults.ErrorWhen.ValueType = ...  # 100
        RUNNING_WORKER: InspectionResults.ErrorWhen.ValueType = ...  # 101
        MOUNTING_GUEST: InspectionResults.ErrorWhen.ValueType = ...  # 200
        INSPECTING_OS: InspectionResults.ErrorWhen.ValueType = ...  # 201
        INSPECTING_BOOTLOADER: InspectionResults.ErrorWhen.ValueType = ...  # 202
        DECODING_WORKER_RESPONSE: InspectionResults.ErrorWhen.ValueType = ...  # 300
        INTERPRETING_INSPECTION_RESULTS: InspectionResults.ErrorWhen.ValueType = ...  # 301
    class ErrorWhen(_ErrorWhen, metaclass=_ErrorWhenEnumTypeWrapper):
        pass

    NO_ERROR: InspectionResults.ErrorWhen.ValueType = ...  # 0
    STARTING_WORKER: InspectionResults.ErrorWhen.ValueType = ...  # 100
    RUNNING_WORKER: InspectionResults.ErrorWhen.ValueType = ...  # 101
    MOUNTING_GUEST: InspectionResults.ErrorWhen.ValueType = ...  # 200
    INSPECTING_OS: InspectionResults.ErrorWhen.ValueType = ...  # 201
    INSPECTING_BOOTLOADER: InspectionResults.ErrorWhen.ValueType = ...  # 202
    DECODING_WORKER_RESPONSE: InspectionResults.ErrorWhen.ValueType = ...  # 300
    INTERPRETING_INSPECTION_RESULTS: InspectionResults.ErrorWhen.ValueType = ...  # 301

    OS_RELEASE_FIELD_NUMBER: builtins.int
    BIOS_BOOTABLE_FIELD_NUMBER: builtins.int
    UEFI_BOOTABLE_FIELD_NUMBER: builtins.int
    ROOT_FS_FIELD_NUMBER: builtins.int
    ERROR_WHEN_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_MS_FIELD_NUMBER: builtins.int
    OS_COUNT_FIELD_NUMBER: builtins.int
    @property
    def os_release(self) -> global___OsRelease:
        """The OS and version detected. Populated when a single OS is
        detected. Empty when none or multiple are found.
        """
        pass
    bios_bootable: builtins.bool = ...
    """bios_bootable indicates whether `os_release` is bootable using bios."""

    uefi_bootable: builtins.bool = ...
    """uefi_bootable indicates whether `os_release` is bootable with UEFI."""

    root_fs: typing.Text = ...
    """root_fs indicates the file system type of the partition containing
    the root directory ("/") of `os_release`.
    """

    error_when: global___InspectionResults.ErrorWhen.ValueType = ...
    """If inspection is not successful, when the error occurred.

    Success is independent of whether results were found. For example,
    inspection of an empty disk will have empty results,
    and error_when will be 'NO_ERROR'.
    """

    elapsed_time_ms: builtins.int = ...
    """Total time spent inspecting. This includes prep, running the worker,
    and tearing down the worker.
    """

    os_count: builtins.int = ...
    """Number of operating systems detected on the disk."""

    def __init__(self,
        *,
        os_release : typing.Optional[global___OsRelease] = ...,
        bios_bootable : builtins.bool = ...,
        uefi_bootable : builtins.bool = ...,
        root_fs : typing.Text = ...,
        error_when : global___InspectionResults.ErrorWhen.ValueType = ...,
        elapsed_time_ms : builtins.int = ...,
        os_count : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["os_release",b"os_release"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bios_bootable",b"bios_bootable","elapsed_time_ms",b"elapsed_time_ms","error_when",b"error_when","os_count",b"os_count","os_release",b"os_release","root_fs",b"root_fs","uefi_bootable",b"uefi_bootable"]) -> None: ...
global___InspectionResults = InspectionResults
